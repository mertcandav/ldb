// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// The LDB data representation reference
// ----------------------------------------------
//
// Special Bytes
//	The separator byte is zero, aka NUL.
//	Separator bytes used to represent EOF of any collection name, value, and data.
//
// Collections
//	Collections are value arrays stored in the database.
//	Each line of database file is a collection-data pair.
//	Collection names cannot include separator byte.
//	In a line, collection identifier cames first, then separator byte,
//	rest of the bytes are the data representation of the collection.
//	Every element should encode and decode with JSON.
//
//	To represent an array element, value data should came first, then EOF byte.
//	To represent end of the collection data, should be used EOF byte.
//
// Example Data Representations
//	"collection1\x00\x00"                   -> name: collection1 data: []
//	"foo\x001\x002\x003\x00\x00"            -> name: foo         data: [1, 2, 3]
//	"bar\x00false\x00false\x00true\x00\x00" -> name: foo         data: [false, false, true]

use "std/bufio"
use "std/bytes"
use "std/io"
use "std/os"
use "std/unicode"
use "std/unsafe"

const (
	_EOF       = 0 // Separator byte.
	_EMPTY_LEN = 1 // Length of the empty collection data including separator byte.
)

fn newDataScanner(mut r: io::Reader): &bufio::Scanner {
	mut scan := bufio::Scanner.New(r)
	scan.Split(bufio::ScanLines)
	scan.Buffer(nil, int.Max)
	ret scan
}

async fn clearDatabase(mut file: &os::File)! {
	file.Truncate(0).await?
}

async fn createCollection[T](mut db: &LDB, name: str)!: &Collection[T] {
	mut offs := db.file.Seek(0, io::SeekEnd).await?
	mut r := name + "\x00\x00"
	if offs > 0 {
		// Add new-line if database is not empty.
		r = "\n" + r
	}
	db.file.WriteStr(r).await?
	offs = db.file.Seek(0, io::SeekEnd).await?
	offs-- // point to EOF byte
	ret &Collection[T]{
		db: db,
		name: name,
		offs: offs,
		len: _EMPTY_LEN,
	}
}

async fn dropCollection(mut file: &os::File, name: str)! {
	file.Seek(0, io::SeekStart).await?
	mut scan := newDataScanner(file)
	mut offs, mut lastoffs := i64(0), i64(0)
	mut remove := false
	for {
		if remove {
			file.Seek(offs, io::SeekStart).await?
			mut rest := io::ReadAll(file).await?
			if scan.EOF() && lastoffs > 0 {
				lastoffs-- // trim new-line
			}
			file.Truncate(lastoffs).await?
			file.Seek(0, io::SeekEnd).await?
			file.Write(rest).await?
			break
		}
		mut ok := scan.Scan().await?
		if !ok {
			break
		}
		mut line := scan.Token()
		collectionName, _ := splitLine(line)
		remove = unsafe::BytesStr(collectionName) == name
		lastoffs = offs
		if !scan.EOF() {
			offs++ // new-line
		}
		offs += i64(len(line))
	}
}

async fn readCollection[T](mut db: &LDB, name: str)!: &Collection[T] {
	db.file.Seek(0, io::SeekStart).await?
	mut scan := newDataScanner(db.file)
	mut offs := i64(0)
	for {
		mut ok := scan.Scan().await?
		if !ok {
			ret nil
		}
		if !scan.EOF() {
			offs++ // new-line
		}
		mut line := scan.Token()
		collectionName, datalen := splitLine(line)
		if unsafe::BytesStr(collectionName) != name {
			offs += i64(len(line))
			continue
		}
		offs += i64(len(collectionName))
		offs++ // separator space

		mut collection := new(Collection[T])
		collection.db = db
		collection.name = str(collectionName)
		collection.offs = offs
		collection.len = datalen

		ret collection
	}
}

async fn readCollectionData(mut file: &os::File, offs: i64, len: i64)!: []byte {
	file.Seek(offs, io::SeekStart).await?
	mut data := make([]byte, len)
	n := file.Read(data).await?
	if i64(n) != len {
		panic("ldb: corrupted database")
	}
	ret data
}

async fn writeCollection[T](mut collection: &Collection[T], data: []byte)! {
	mut file := collection.db.file
	file.Seek(collection.offs+collection.len, io::SeekStart).await?
	mut rest := io::ReadAll(file).await?
	file.Truncate(collection.offs).await?
	file.Seek(0, io::SeekEnd).await?
	file.Write(data).await?
	file.Write(rest).await?
}

// Reads collection names from the database file.
async fn readCollections(mut f: &os::File)!: (collections: []str) {
	f.Seek(0, io::SeekStart).await?
	mut scan := newDataScanner(f)
	for {
		ok := scan.Scan().await?
		if !ok {
			break
		}
		mut line := scan.Token()
		name, _ := splitLine(line)
		collections = append(collections, str(name))
	}
	ret
}

fn splitLine(mut line: []byte): (name: []byte, datalen: i64) {
	i := bytes::IndexByte(line, _EOF)
	if i == -1 {
		panic("ldb: corrupted database")
	}
	name = bytes::TrimSpace(line[:i])
	datalen = i64(len(line[i+1:]))
	if len(name) == 0 || datalen == 0 {
		panic("ldb: corrupted database")
	}
	ret
}

// Reports whether the name is suitable for LDB collection.
fn isValidName(name: str): bool {
	ret bytes::IndexByte(unsafe::StrBytes(name), _EOF) < 0
}