// Copyright 2025 mertcandav.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/encoding/json"
use "std/sync"

// Database access modes.
const (
	_READ = iota
	_WRITE
)

// LDB collection instance.
// A Collection instance must not be copied.
struct Collection[T] {
	mut db: &LDB

	mu: sync::Mutex

	name: str
	offs: i64 // Offset of the data in the database representation.
	len:  i64 // Length of the collection data.

	// Cache for the internal data.
	mut cache: []byte
}

impl Collection {
	// Returns name of the collection.
	fn Name(&self): str {
		ret self.name
	}

	// Checks the database connection and panics with msg if it is closed.
	// Locks for the relevant access mode before return.
	async fn isOpen(&self, access: int, msg: str) {
		if self.db == nil {
			panic(msg)
		}
		if access&_WRITE == _WRITE {
			self.db.writeLock().await
		} else {
			self.db.readLock().await
		}
		if !self.db.IsOpen() {
			panic(msg)
		}
	}

	// Returns collection data from the non-volatile memory.
	async fn readData(&self)!: []byte {
		if self.cache == nil {
			self.cache = readCollectionData(self.db.file, self.offs, self.len).await?
		}
		ret self.cache
	}

	// Returns number of records in the collection.
	async fn Len(&self)!: (n: int) {
		self.isOpen(_READ, "Collection.Len: database connection is closed").await

		mut data := self.readData().await?
		self.db.readUnlock()

		for _, b in data {
			if b == _EOF {
				n++
			}
		}
		n-- // Remove trailing EOF byte of the data.
		ret
	}

	// Iterates values of collection.
	async fn Iter(mut &self, f: fn(mut T))! {
		self.isOpen(_READ, "Collection.Iter: database connection is closed").await

		mut data := self.readData().await?
		self.db.readUnlock()

		mut scan := scanner.new(data)
		for {
			mut token := scan.scan()
			if token == nil { // EOF
				break
			}
			let mut v: T
			json::Decode(token, &v)?
			f(v)
		}
	}

	// Iterates values of collection.
	// Breaks iteration when function f returns false.
	async fn Iter2(mut &self, f: fn(mut T): bool)! {
		self.isOpen(_READ, "Collection.Iter: database connection is closed").await

		mut data := self.readData().await?
		self.db.readUnlock()

		mut scan := scanner.new(data)
		for {
			mut token := scan.scan()
			if token == nil { // EOF
				break
			}
			let mut v: T
			json::Decode(token, &v)?
			if !f(v) {
				break
			}
		}
	}

	// Appends values to collection.
	async fn Append(mut &self, mut values: ...T)! {
		self.isOpen(_WRITE, "Collection.Append: database connection is closed").await
		defer { self.db.writeUnlock() }

		mut data := self.readData().await?
		data = data[:len(data)-1] // remove trailing EOF byte
		for _, v in values {
			bytes := json::Encode(v)?
			data = append(data, bytes...)
			data = append(data, _EOF) // Add trailing zero byte to EOF for the value.
		}
		data = append(data, _EOF) // Add trailing EOF zero byte for the data.

		writeCollection(self, data).await?
		self.len = i64(len(data))
		self.cache = data
	}

	// Maps data to result of f.
	async fn Map(mut &self, f: fn(T): T)! {
		self.isOpen(_WRITE, "Collection.Map: database connection is closed").await
		defer { self.db.writeUnlock() }

		mut data := self.readData().await?
		mut scan := scanner.new(data)
		data = make([]byte, 0)
		for {
			mut token := scan.scan()
			if token == nil { // EOF
				break
			}
			let mut v: T
			json::Decode(token, &v)?
			v = f(v)
			bytes := json::Encode(v)?
			data = append(data, bytes...)
			data = append(data, _EOF) // Add trailing zero byte to EOF for the value.
		}
		data = append(data, _EOF) // Add trailing EOF zero byte for the data.

		writeCollection(self, data).await?
		self.len = i64(len(data))
		self.cache = data
	}

	// Updates data by f.
	// The function f must filter data if needed and update the mutable reference.
	async fn Update(mut &self, f: fn(mut &t: *T))! {
		self.isOpen(_WRITE, "Collection.Update: database connection is closed").await
		defer { self.db.writeUnlock() }

		mut data := self.readData().await?
		mut scan := scanner.new(data)
		data = make([]byte, 0)
		for {
			mut token := scan.scan()
			if token == nil { // EOF
				break
			}
			let mut v: T
			json::Decode(token, &v)?
			f(&v)
			bytes := json::Encode(v)?
			data = append(data, bytes...)
			data = append(data, _EOF) // Add trailing zero byte to EOF for the value.
		}
		data = append(data, _EOF) // Add trailing EOF zero byte for the data.

		writeCollection(self, data).await?
		self.len = i64(len(data))
		self.cache = data
	}

	// Filters and removes matched data by f.
	async fn Delete(mut &self, f: fn(T): bool)! {
		self.isOpen(_WRITE, "Collection.Delete: database connection is closed").await
		defer { self.db.writeUnlock() }

		mut data := self.readData().await?
		mut scan := scanner.new(data)
		data = make([]byte, 0)
		for {
			mut token := scan.scan()
			if token == nil { // EOF
				break
			}
			let mut v: T
			json::Decode(token, &v)?
			if !f(v) {
				data = append(data, token...)
				data = append(data, _EOF) // Add trailing zero byte to EOF for the value.
			}
		}
		data = append(data, _EOF) // Add trailing EOF zero byte for the data.

		writeCollection(self, data).await?
		self.len = i64(len(data))
		self.cache = data
	}

	// Clears internal cache.
	// It may help to reduce memory use.
	// But triggers caching and reading from non-volatile memory in next CRUD.
	// Unnecessary use of this method may cause significant performance issues.
	async fn ClearCache(mut &self) {
		self.db.writeLock().await
		defer { self.db.writeUnlock() }
		self.cache = nil
	}

	// Returns ready-to-use query for the collection.
	// Panics if database-read fails.
	// Locks the read-lock, avoid misuse of Query, otherwise behavior is undefined.
	async fn Query(mut &self): Query[T] {
		self.isOpen(_READ, "Collection.Query: database connection is closed").await

		mut data := self.readData().await!
		ret Query[T]{
			owner: self,
			data: data,
		}
	}

	// Drops the collection ownership.
	// When a collection closed, all collections will be closed for the same name.
	async fn Close(mut &self) {
		self.isOpen(_WRITE, "Collection.Close: database connection is closed").await
		self.mu.Lock().await
		defer { self.mu.Unlock() }

		delete(self.db.cache, self.name)

		self.db.writeUnlock()

		self.db = nil
		self.name = ""
		self.len = 0
		self.offs = 0
		self.cache = nil
	}
}